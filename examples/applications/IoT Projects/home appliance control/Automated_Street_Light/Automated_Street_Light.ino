// -----------------------------------------------------------------------------
// Project: Smart Streetlight Timer with Auto/Manual Mode
// File: Smart_Streetlight_Timer.ino
// Description: Controls a NeoPixel streetlight based on ambient light (LDR)
//              or manual override. Features a physical button to toggle
//              auto/manual mode and an indicator LED. Time is synced via Cloud.
// -----------------------------------------------------------------------------

// Include necessary libraries for Arduino IoT Cloud, NeoPixel, and Time functions.
#include "thingProperties.h"   // Auto-generated by Arduino IoT Cloud
#include <Adafruit_NeoPixel.h> // For NeoPixel Ring
#include <TimeLib.h>           // For time functions (hour(), minute(), etc.)

// -----------------------------------------------------------------------------
// Pin Definitions
// -----------------------------------------------------------------------------
#define LDR_PIN A0             // Analog pin for Light Dependent Resistor (LDR)
#define NEOPIXEL_PIN D5        // Digital pin for NeoPixel data
#define NUM_PIXELS 16          // Number of NeoPixels in the ring
#define MODE_SWITCH_PIN D2     // Digital pin for Push-button/Rocker switch (to toggle mode)
#define STATUS_LED_PIN D3      // Digital pin for Status LED (ON = Auto, OFF = Manual)

// -----------------------------------------------------------------------------
// Actuator Object
// -----------------------------------------------------------------------------
Adafruit_NeoPixel pixels(NUM_PIXELS, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800); // NeoPixel object

// -----------------------------------------------------------------------------
// Constants and Thresholds
// -----------------------------------------------------------------------------
const long SENSOR_READ_INTERVAL = 5000; // Read LDR and update time every 5 seconds
const long BUTTON_DEBOUNCE_DELAY = 50; // Debounce time for mode switch button (milliseconds)

// LDR values: typically higher value = darker, lower value = brighter.
// Calibrate these based on your LDR and environment.
const int DEFAULT_LIGHT_THRESHOLD = 500; // Default LDR value to turn light ON (adjust as needed)
                                         // If ambientLight > lightThreshold, it's dark enough to turn ON.

// -----------------------------------------------------------------------------
// Global Variables (for internal use, not directly linked to Cloud Properties)
// -----------------------------------------------------------------------------
unsigned long lastLDRReadTime = 0;       // To control LDR reading frequency
int lastButtonState = HIGH;              // Last reading from the mode switch button
unsigned long lastDebounceTime = 0;      // Last time the button pin was toggled

// -----------------------------------------------------------------------------
// Setup Function: Runs once when the board starts
// -----------------------------------------------------------------------------
void setup() {
  // Initialize Serial communication for debugging
  Serial.begin(9600);
  while (!Serial); // Wait for Serial Monitor to open

  // Initialize Arduino IoT Cloud properties
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  // Set debug message level for more detailed output
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Initialize NeoPixel ring
  pixels.begin();
  pixels.show(); // Initialize all pixels to 'off'
  Serial.println("NeoPixel initialized.");

  // Set pin modes
  pinMode(LDR_PIN, INPUT);
  pinMode(MODE_SWITCH_PIN, INPUT_PULLUP); // Use internal pull-up for the button
  pinMode(STATUS_LED_PIN, OUTPUT);

  // Initialize Cloud properties to default values
  streetlightOn = false;
  autoModeEnabled = true; // Start in auto mode by default
  statusLedState = true;  // Status LED ON for Auto mode
  lightThreshold = DEFAULT_LIGHT_THRESHOLD;
  strcpy(onTime, "18:00"); // Default ON time
  strcpy(offTime, "06:00"); // Default OFF time

  digitalWrite(STATUS_LED_PIN, statusLedState ? HIGH : LOW); // Set initial status LED state

  Serial.println("Setup complete for Smart Streetlight Timer.");
}

// -----------------------------------------------------------------------------
// Loop Function: Runs repeatedly
// -----------------------------------------------------------------------------
void loop() {
  // Update Arduino IoT Cloud state (sends/receives data)
  ArduinoCloud.update();

  // Read LDR and update time periodically
  if (millis() - lastLDRReadTime > SENSOR_READ_INTERVAL) {
    readSensors();
    lastLDRReadTime = millis();
  }

  // Handle physical mode switch
  handleModeSwitch();

  // Control streetlight based on current mode
  if (autoModeEnabled) {
    handleAutomaticLighting();
  } else {
    handleManualLighting();
  }
}

// -----------------------------------------------------------------------------
// Function to read LDR, get current time, and update Cloud properties
// -----------------------------------------------------------------------------
void readSensors() {
  // Read LDR value
  int rawLDR = analogRead(LDR_PIN);
  ambientLight = rawLDR; // Update Cloud property
  Serial.print("Ambient Light (LDR): "); Serial.println(ambientLight);

  // Get Current Time from Cloud-synced RTC
  time_t currentEpochTime = now();
  sprintf(currentTime, "%02d:%02d:%02d", hour(currentEpochTime), minute(currentEpochTime), second(currentEpochTime));
  Serial.print("Current Time: "); Serial.println(currentTime);
}

// -----------------------------------------------------------------------------
// Function to handle the physical mode switch (button)
// -----------------------------------------------------------------------------
void handleModeSwitch() {
  int reading = digitalRead(MODE_SWITCH_PIN);

  // If the switch changed, due to noise or pressing:
  if (reading != lastButtonState) {
    // Reset the debouncing timer
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > BUTTON_DEBOUNCE_DELAY) {
    // If the button state has been stable for the debounce time
    if (reading != autoModeEnabled) { // Check if the physical button state implies a mode change
      // Toggle autoModeEnabled
      autoModeEnabled = !autoModeEnabled;
      Serial.print("Physical switch toggled mode to: ");
      Serial.println(autoModeEnabled ? "AUTO" : "MANUAL");
      // Update Cloud property to reflect physical switch state
      // (This will also trigger onAutoModeEnabledChange callback)
    }
  }
  lastButtonState = reading; // Save the current button state for next iteration
}

// -----------------------------------------------------------------------------
// Function to control the NeoPixel streetlight
// -----------------------------------------------------------------------------
void setStreetlightState(bool state) {
  if (state) {
    pixels.fill(pixels.Color(255, 255, 0), 0, NUM_PIXELS); // Yellow light for ON
    pixels.show();
    if (!streetlightOn) { // Only print if state changes
      Serial.println("Streetlight ON.");
    }
    streetlightOn = true; // Update Cloud property
  } else {
    pixels.clear(); // Turn all pixels off
    pixels.show();
    if (streetlightOn) { // Only print if state changes
      Serial.println("Streetlight OFF.");
    }
    streetlightOn = false; // Update Cloud property
  }
}

// -----------------------------------------------------------------------------
// Function to handle automatic lighting logic (LDR-based)
// -----------------------------------------------------------------------------
void handleAutomaticLighting() {
  // Update status LED for auto mode
  if (!statusLedState) {
    statusLedState = true;
    digitalWrite(STATUS_LED_PIN, HIGH);
    Serial.println("Status LED: AUTO Mode (ON)");
  }

  // If ambient light is below threshold (dark), turn light ON
  if (ambientLight > lightThreshold) { // Higher LDR value means darker
    setStreetlightState(true);
  } else {
    // If ambient light is above threshold (bright), turn light OFF
    setStreetlightState(false);
  }

  // --- Optional: Time-based override for auto mode (more advanced) ---
  // You could add logic here to override LDR based on specific times
  // For example, force ON between onTime and offTime regardless of LDR.
  // This requires parsing the time strings into comparable values.
  // For simplicity, the primary auto mode is LDR-based as requested.
}

// -----------------------------------------------------------------------------
// Function to handle manual lighting logic
// -----------------------------------------------------------------------------
void handleManualLighting() {
  // Update status LED for manual mode
  if (statusLedState) {
    statusLedState = false;
    digitalWrite(STATUS_LED_PIN, LOW);
    Serial.println("Status LED: MANUAL Mode (OFF)");
  }

  // Light state is directly controlled by the 'streetlightOn' Cloud property
  setStreetlightState(streetlightOn);
}

// -----------------------------------------------------------------------------
// Arduino IoT Cloud Callbacks
// -----------------------------------------------------------------------------

/*
  Callback function for when the streetlightOn property changes in the Cloud.
  This allows manual control of the streetlight, but only applies if autoModeEnabled is false.
*/
void onStreetlightOnChange() {
  Serial.print("Cloud changed Streetlight On to: ");
  Serial.println(streetlightOn ? "TRUE" : "FALSE");
  if (!autoModeEnabled) { // Only apply manual change if not in auto mode
    setStreetlightState(streetlightOn);
  } else {
    Serial.println("Manual override ignored: System is in AUTO mode.");
    // Optionally, revert the cloud property to match the current physical state if auto mode is active
    // streetlightOn = !streetlightOn; // This would revert the switch on the dashboard
  }
}

/*
  Callback function for when the autoModeEnabled property changes in the Cloud.
  This allows remote toggling between automatic and manual modes.
*/
void onAutoModeEnabledChange() {
  Serial.print("Cloud changed Auto Mode Enabled to: ");
  Serial.println(autoModeEnabled ? "TRUE" : "FALSE");
  // The loop will pick up this change and switch control logic.
  // Update local status LED immediately
  digitalWrite(STATUS_LED_PIN, autoModeEnabled ? HIGH : LOW);
}

/*
  Callback function for when the onTime property changes in the Cloud.
  This updates the automatic ON time.
*/
void onOnTimeChange() {
  Serial.print("Cloud changed ON Time to: ");
  Serial.println(onTime);
  // No direct action needed here, the auto mode logic would use this if implemented.
}

/*
  Callback function for when the offTime property changes in the Cloud.
  This updates the automatic OFF time.
*/
void onOffTimeChange() {
  Serial.print("Cloud changed OFF Time to: ");
  Serial.println(offTime);
  // No direct action needed here, the auto mode logic would use this if implemented.
}

/*
  Callback function for when the lightThreshold property changes in the Cloud.
  This updates the LDR threshold for automatic control.
*/
void onLightThresholdChange() {
  Serial.print("Cloud changed Light Threshold to: ");
  Serial.println(lightThreshold);
  // No direct action needed here, handleAutomaticLighting() will respect this value.
}

/*
  Callback functions for read-only properties (for monitoring/debugging).
*/
void onCurrentTimeChange() {
  Serial.print("Cloud attempted to change Current Time to: ");
  Serial.println(currentTime);
}

void onAmbientLightChange() {
  Serial.print("Cloud attempted to change Ambient Light to: ");
  Serial.println(ambientLight);
}

void onStatusLedStateChange() {
  Serial.print("Cloud attempted to change Status LED State to: ");
  Serial.println(statusLedState ? "TRUE" : "FALSE");
}
